<h1>Лекция 1: Lecture01 - Windows Forms.csproj</h1>
<h2>Стайд 1: Hello, Windows Forms</h2><ul>
<li> Windows Forms - устаревающая технология. Тем не менее, в свое время она была настоящим прорывом
<li> Она является оберткой над User32, которая содержит WinAPI для контролов. И таких оберток было множество: MFC, OWL от борланд, и т.д.
<li> Но WF стало очень популярно. Одна из причин - события, каллбэки к действиям пользователя: легко пользоваться (в отличие от OWL), типобезопасно (в отличие от C++)
</ul>
<h2>Стайд 2: Declaring Form</h2><ul>
<li>Часто все контролы заворачивают в класс, производный от Form. 
<li>Обратите внимание, что событие теперь обрабатывается двумя обработчиками
</ul>
<h2>Стайд 3: Designer</h2><ul>
</ul>
<h2>Стайд 4: GDI</h2><ul>
<li>GDI+ - другая библиотека WinAPI
<li>Позволяет делать множество всяких штук, связанных с графикой, т.ж. содержит графические примитивы
</ul>
<h1>Лекция 2: Lecture02 - WPF, XAML и элементы управления.csproj</h1>
<h2>Стайд 1: Hello, WPF</h2><ul>
<li>WPF - это не обертка над User32. Это совершенно новый фреймворк, который вообще не использует WinAPI, он использует DirectX. Это - скорее не новая библиотека для программирования, а в целом новая система интерфейса.
<li>Он содержит множество разных инструментов для работы с данными, графикой, видео и аудио (что в WinForms приходилось делать через обертки типа SlimDX, из которых отовсюду торчали уши двоичного кода)
<li>Тем не менее, в некоторых областях (3D) он откровенно сырой. Кроме того, это такой шалаш из костылей.
<li>Видно, что код стал несколько неудобным. Но его так писать не нужно!
</ul>
<h2>Стайд 2: XAML</h2><ul>
<li>XAML - Это язык для описания объектов, со вложенными полями. Можно описывать произвольные объекты, но чаще всего мы будем описывать элементы УИ.
</ul>
<h2>Стайд 3: XAML</h2><ul>
<li>Можно писать код прямо в XAML, но это неудобно, и делается, по-моему, только для примеров на MSDN.
</ul>
<h2>Стайд 4: XAML</h2><ul>
<li>Элемент Window принимает Content. Когда я описываю тэг Window, я описывают, что будет присвоено Content.
<li>Content - Это ОДИН элемент. Если я хочу много, нужно взять компоновщик, который будет принимать коллекцию объектов, я беру StackPanel
<li>У Button тоже есть Content. Я могу написать его в атрибуте, или в виде содержимого тэга.
<li>Важно, что Content Button - это, как и Content у окна, все что угодно. Например, StackPanel. Обратите внимание, как я пишу графику в XAML
<li>Другие поля класса тоже могут быть определены: Background
<li>Чудес не бывает, все это компилируется на лету в шарповый код, который просто создает классы и метод InitializeComponents, где свойства
<li>Все, что можно сделать XAML, можно сделать и без него, но это самый популярный вопрос: как сделать нечто без XAML
<li>А вот так можно поименовать элемент (только это не всегда стоит делать!), подписаться на событие.
<li>Но на самом деле, на события тоже следует подписываться не всегда. Огромное количество действий можно делать в XAML, и в основном мы будем заниматься именно этим.
</ul>
<h2>Стайд 5: WrapPanel, Ellipses, Rectangles</h2><ul>
</ul>
<h2>Стайд 6: DockPanel, Labels</h2><ul>
</ul>
<h2>Стайд 7: Grid</h2><ul>
</ul>
<h2>Стайд 8: Combination of containers</h2><ul>
</ul>
<h2>Стайд 9: TextBox, ComboBox, CheckBox</h2><ul>
</ul>
<h2>Стайд 10: Tabs, GroupBox, RadioButton</h2><ul>
</ul>
<h2>Стайд 11: Menu, Toolbar</h2><ul>
</ul>
<h2>Стайд 12: Headers</h2><ul>
</ul>
<h2>Стайд 13: Images</h2><ul>
</ul>
<h2>Стайд 14: ListBox, ComboBox and TreeView</h2><ul>
</ul>
<h1>Лекция 3: Lecture03 - Внешний вид элементов управления.csproj</h1>
<h2>Стайд 1: Ресурсы</h2><ul>
<li>Ресурс - это объект, объявленный в XAML, на который потом можно сослаться
</ul>
<h2>Стайд 2: Доступ к ресурсам из кода</h2><ul>
<li>Можно сослаться из кода: либо установить ссылку, либо непосредственно взять и присвоить объект
</ul>
<h2>Стайд 3: Статические и динамические ресурсы</h2><ul>
<li>Разница между статическими и динамическими ресурсами
</ul>
<h2>Стайд 4: Библиотеки ресурсов</h2><ul>
<li>Ресурсы можно убрать в библиотеки
</ul>
<h2>Стайд 5: Стили</h2><ul>
<li> Стиль - это просто присвоение определенных полей элемента, которое часто повторяется и поэтому убрано в отдельную сущность.
<li> Стиль - это не обязательно про внешний вид!
</ul>
<h2>Стайд 6: Указание целевого типа стиля</h2><ul>
</ul>
<h2>Стайд 7: Наследование стилей</h2><ul>
</ul>
<h2>Стайд 8: Шаблон</h2><ul>
<li>Шаблон определяет как будет выглядеть элемент управления. И ТОЛЬКО ОН!
<li>Шаблоны контролов нужно определять в стилях
</ul>
<h2>Стайд 9: TemplateBinding в шаблоне</h2><ul>
</ul>
<h2>Стайд 10: Binding через конвертор</h2><ul>
</ul>
<h2>Стайд 11: Двухсторонний биндинг</h2><ul>
</ul>
<h2>Стайд 12: Шаблоны для отображения коллекций</h2><ul>
</ul>
<h2>Стайд 13: Темы</h2><ul>
</ul>
<h1>Лекция 4: Lecture04 - Биндинг данных, конвертеры, валидация.csproj</h1>
<h2>Стайд 1: Биндинг данных</h2><ul>
<li> Binding по умолчанию отсчитывается от DataContext
</ul>
<h2>Стайд 2: Биндинг вложенных полей</h2><ul>
</ul>
<h2>Стайд 3: Двухсторонний биндинг</h2><ul>
<li>Это не будет работать, потому что WPF не знает, что поле изменилось.
</ul>
<h2>Стайд 4: INotifyPropertyChanged</h2><ul>
<li>Мы сообщаем об изменении поля с помощью интерфейса INotifyPropertyChanged
</ul>
<h2>Стайд 5: Конвертер</h2><ul>
</ul>
<h2>Стайд 6: Валидация через Exception</h2><ul>
</ul>
<h2>Стайд 7: Валидация через IDataErrorInfo</h2><ul>
</ul>
<h2>Стайд 8: Валидаторы</h2><ul>
</ul>
<h2>Стайд 9: Шаблоны отображения ошибок</h2><ul>
</ul>
<h2>Стайд 10: Сахар для INotiftPropertyChanged</h2><ul>
</ul>
<h1>Лекция 5: Lecture05 - Биндинг коллекций.csproj</h1>
<h2>Стайд 2: Обновление интерфейса вручную</h2><ul>
</ul>
<h2>Стайд 3: ObservableCollection</h2><ul>
</ul>
<h2>Стайд 4: Определение шаблона отображения</h2><ul>
</ul>
<h2>Стайд 5: Привязка Главная-Детали</h2><ul>
</ul>
<h2>Стайд 6: TreeView</h2><ul>
</ul>
<h2>Стайд 7: DataGrid</h2><ul>
</ul>
<h2>Стайд 8: Типы редактирования столбцов</h2><ul>
</ul>
<h1>Лекция 6: Lecture06 - События и команды.csproj</h1>
<h2>Стайд 1: Делегаты</h2><ul>
<li> Что такое событие? Сначала поймем, что такое делегат - ссылка на функцию. Action<int> - ссылка на фунцкию, обрабатывающую int
<li> Я использую lambda-синтаксис: это то же самое, что определить метод и сослаться на него. Но это короче, и когда в программе 100 мелких обработчиков, это удобно.
<li> Но делегат - небезопасен: если его можно установить, значит, можно и вызвать.
</ul>
<h2>Стайд 2: Событие</h2><ul>
<li>Событие есть обертка над делегатом - подобно тому, как свойство есть обертка над полем. Это пара методов, add и remove.
</ul>
<h2>Стайд 3: Автособытие</h2><ul>
<li> Чаще всего, событие пишут автосинтаксисом (также, как и свойства). Но важно понимать, что это по-прежнему пара методов, и компилятор автоматически создает поле-делегат.
</ul>
<h2>Стайд 4: Архитектура событий</h2><ul>
<li>Полный синтаксис события: так нужно писать по рекомендациям Microsoft. 
</ul>
<h2>Стайд 5: Всплывающие события</h2><ul>
<li>args.Handled=true|false
</ul>
<h2>Стайд 6: Туннелирующие события</h2><ul>
<li>args.Handled=true|false
</ul>
<h2>Стайд 7: Команды</h2><ul>
</ul>
<h2>Стайд 8: Биндинг команды</h2><ul>
</ul>
<h2>Стайд 9: Создание собственной команды</h2><ul>
</ul>
